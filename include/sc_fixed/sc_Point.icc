#ifndef __SC_POINT_ICC__
#define __SC_POINT_ICC__

#include <cmath>
#include "sc_fixed/sc_fixed_math.h"
/**
 *  @file
 *  @brief Implementation of a 3D point.
 *
 *  Representation of a 3D point.
 *  Only inline functions are used, therefore no .cc file.
 *
 *  @author Tom Fleischmann, Jonas Wiesner, Yannik Winzer - University of Wuerzburg, Germany
 **/

/**
 * Default constructor
 */
inline sc_Point::sc_Point()
{
  x = y = z = 0.0;
  point_id = 0;
  type = 0;
  reflectance = 0.0;
  temperature = 0.0;
  amplitude = 0.0;
  deviation = 0.0;
  rgb[0] = 255; rgb[1] = 255; rgb[2] = 255;
  nx = 1.0; ny = nz = 0.0;
}

/**
 * Copy constructor
 */
inline sc_Point::sc_Point(const sc_Point& p)
{
  x = p.x;
  y = p.y;
  z = p.z;
  nx = p.nx;
  ny = p.ny;
  nz = p.nz;
  type = p.type;
  point_id = p.point_id;
  reflectance = p.reflectance;
  temperature = p.temperature;
  amplitude = p.amplitude;
  deviation = p.deviation;
  rgb[0] = p.rgb[0];
  rgb[1] = p.rgb[1];
  rgb[2] = p.rgb[2];
}

/**
  *	Constructor with an array, i.e., vecctor of coordinates
  */
inline sc_Point::sc_Point(const double *p)
{
  x = p[0];
  y = p[1];
  z = p[2];
  nx = 1.0; ny = nz = 0.0;
  type = 0;
  point_id = 0;
  reflectance = 0.0;
  temperature = 0.0;
  amplitude = 0.0;
  deviation = 0.0;
  rgb[0] = 255;
  rgb[1] = 255;
  rgb[2] = 255;
};

inline sc_Point::sc_Point(const double *p, const char *c)
{
  x = p[0]; y = p[1]; z = p[2];
  nx = 1.0; ny = nz = 0.0;
  type = 0;
  point_id = 0;
  reflectance = 0.0;
  temperature = 0.0;
  amplitude = 0.0;
  deviation = 0.0;
  rgb[0] = c[0];
  rgb[1] = c[1];
  rgb[2] = c[2];
}

/**
 *	Constructor with three double values
 */
inline sc_Point::sc_Point(const double _x, const double _y, const double _z)
{
  x = _x;
  y = _y;
  z = _z;
  nx = 1.0; ny = nz = 0.0;
  type = 0;
  point_id = 0;
  reflectance = 0.0;
  temperature = 0.0;
  amplitude = 0.0;
  deviation = 0.0;
  rgb[0] = 255;
  rgb[1] = 255;
  rgb[2] = 255;
}

/**
 *	Constructor with three double values
 */
inline sc_Point::sc_Point(const double _x, const double _y, const double _z,
				const double _nx, const double _ny, const double _nz)
{
  nx = _nx;
  ny = _ny;
  nz = _nz;
  x = _x;
  y = _y;
  z = _z;
  type = 0;
  point_id = 0;
  reflectance = 0.0;
  temperature = 0.0;
  amplitude = 0.0;
  deviation = 0.0;
  rgb[0] = 255;
  rgb[1] = 255;
  rgb[2] = 255;
}

inline sc_Point::sc_Point(const double _x, const double _y, const double _z,
				const char _r, const char _g, const char _b)
{
  x = _x;
  y = _y;
  z = _z;
  nx = 1.0; ny = nz = 0.0;
  type = 0;
  point_id = 0;
  reflectance = 0.0;
  temperature = 0.0;
  amplitude = 0.0;
  deviation = 0.0;
  rgb[0] = _r;
  rgb[1] = _g;
  rgb[2] = _b;
}

inline sc_Point sc_Point::operator+(const sc_Point &p) const
{
  sc_Point res;
  res.x = x + p.x;
  res.y = y + p.y;
  res.z = z + p.z;
  return res;
};

inline sc_Point sc_Point::operator-(const sc_Point &p) const
{
  sc_Point res;
  res.x = x - p.x;
  res.y = y - p.y;
  res.z = z - p.z;
  return res;
};

inline sc_Point& sc_Point::operator-=(const sc_Point &p)
{
  x -= p.x;
  y -= p.y;
  z -= p.z;
  return *this;
};

inline sc_Point& sc_Point::operator+=(const sc_Point &p)
{
  x += p.x;
  y += p.y;
  z += p.z;
  return *this;
};

inline bool sc_Point::operator!=(const sc_Point &p) const
{
  // check all properties except point_id
  return (x != p.x) || (y != p.y) || (z != p.z)
      || (nx != p.nx) || (ny != p.ny) || (nz != p.nz)
      || (type != p.type)
      || (reflectance != p.reflectance)
      || (temperature != p.temperature)
      || (amplitude != p.amplitude)
      || (deviation != p.deviation)
      || (rgb[0] != p.rgb[0])
      || (rgb[1] != p.rgb[1])
      || (rgb[2] != p.rgb[2]);
}

inline bool sc_Point::operator==(const sc_Point &p) const
{
  // check all properties except point_id
  return (x == p.x) && (y == p.y) && (z == p.z)
      && (nx == p.nx) && (ny == p.ny) && (nz == p.nz)
      && (type == p.type)
      && (reflectance == p.reflectance)
      && (temperature == p.temperature)
      && (amplitude == p.amplitude)
      && (deviation == p.deviation)
      && (rgb[0] == p.rgb[0])
      && (rgb[1] == p.rgb[1])
      && (rgb[2] == p.rgb[2]);
}

/**
 *  Overridden "<<" operator for sending a sc_point to a stream
 */
inline std::ostream& operator<<(std::ostream& os, const sc_Point& p) {
  os << p.x << " " << p.y << " " << p.z << " (";
  os << p.nx << " " << p.ny << " " << p.nz << " ";
  os << (int)p.rgb[0] << " " << (int)p.rgb[1] << " " << (int)p.rgb[2] << ")";
  return os;
}

/**
 *  Overridden ">>" operator for reading a sc_point from a stream.
 *  Throws a runtime error if not enough data in the stream.
 */
inline std::istream& operator>>(std::istream& is, sc_Point& p) {
  if (!is.good()) throw std::runtime_error("Not enough elements to read for >>(istream&, sc_Point).1");
  is >> p.x;
  if (!is.good()) throw std::runtime_error("Not enough elements to read for >>(istream&, sc_Point).2");
  is >> p.y;
  if (!is.good()) throw std::runtime_error("Not enough elements to read for >>(istream&, sc_Point).3");
  is >> p.z;
  return is;
}

/**
  * Transforms a sc_point by the given transformation.
  * @param *alignxf The transformation (4x4 matrix)
  */
inline void sc_Point::transform(const double *alignxf)
{
  double x_neu, y_neu, z_neu;
  x_neu = x * alignxf[0] + y * alignxf[4] + z * alignxf[8];
  y_neu = x * alignxf[1] + y * alignxf[5] + z * alignxf[9];
  z_neu = x * alignxf[2] + y * alignxf[6] + z * alignxf[10];
  x = x_neu + alignxf[12];
  y = y_neu + alignxf[13];
  z = z_neu + alignxf[14];
}

/**
  * Calculates the difference between two points.
  * @param p The second sc_point
  */

inline double sc_Point::distance(const sc_Point &p)
{
  double distance;
  distance = (p.x - x)*(p.x - x) + (p.y - y)*(p.y - y) + (p.z - z)*(p.z - z);
  return sqrt(distance);
}

#endif
